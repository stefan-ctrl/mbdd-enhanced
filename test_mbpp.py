import sys
from pathlib import Path
import importlib.util
import pytest


def import_code_module(code_dir: Path, module_name: str):
    if str(code_dir) not in sys.path:
        sys.path.insert(0, str(code_dir))
    py_path = code_dir / f"{module_name}.py"
    if not py_path.exists():
        raise FileNotFoundError(f"Code file not found for task '{module_name}': {py_path}")
    spec = importlib.util.spec_from_file_location(module_name, str(py_path))
    mod = importlib.util.module_from_spec(spec)
    assert spec.loader is not None
    spec.loader.exec_module(mod)
    return mod


def decode_escapes(s: str) -> str:
    # Minimal decoding for common escapes
    if "\\n" in s and "\n" not in s:
        s = s.replace("\\n", "\n")
    if "\\t" in s and "\t" not in s:
        s = s.replace("\\t", "\t")
    s = s.replace('\\"', '"').replace("\\'", "'")
    return s


def read_tests_file(tests_path: Path) -> str:
    content = tests_path.read_text(encoding="utf-8")
    # Tests generated by split_mbpp.py should already have proper newlines.
    # Keep minimal decoding for safety if escapes are present.
    return decode_escapes(content)


def build_cases():
    repo_root = Path(__file__).parent
    sources = [
        ("sanitized", repo_root / "sanitized" / "code", repo_root / "sanitized" / "tests"),
        ("original", repo_root / "original" / "code", repo_root / "original" / "tests"),
    ]
    cases = []
    for label, code_dir, tests_dir in sources:
        if not tests_dir.exists():
            continue
        for tests_path in sorted(tests_dir.glob("*.py")):
            task_id = tests_path.stem
            assertions = read_tests_file(tests_path)
            code_path = code_dir / f"{task_id}.py"
            try:
                mod = import_code_module(code_dir, task_id)
            except Exception as e:
                cases.append((f"{label}:{task_id}", None, f"ImportError: {e}", code_path, tests_path))
                continue
            cases.append((f"{label}:{task_id}", mod, assertions, code_path, tests_path))
    return cases


CASES = build_cases()


@pytest.mark.parametrize(
    "case_id, mod, assertions_src, code_path, tests_path",
    CASES,
    ids=[c[0] for c in CASES] if CASES else None,
)
def test_mbpp_task(case_id, mod, assertions_src, code_path: Path, tests_path: Path):
    if mod is None:
        pytest.fail(
            f"Import failed for {case_id}.\n"
            f"Code: {code_path}\n"
            f"Tests: {tests_path}\n"
            f"Details: {assertions_src}",
            pytrace=True,
        )

    globals_ctx = {"mod": mod}
    globals_ctx.update(vars(mod))
    try:
        exec(assertions_src, globals_ctx, {})
    except Exception as e:
        pytest.fail(
            f"{type(e).__name__}: {e}\n"
            f"Case: {case_id}\n"
            f"Code: {code_path}\n"
            f"Tests: {tests_path}",
            pytrace=True,
        )
